From f745ff58c0c3bd0b6bd69ad39950aba9b8dc5327 Mon Sep 17 00:00:00 2001
From: Ikey Doherty <ikey@solus-project.com>
Date: Mon, 27 Nov 2017 22:39:18 +0000
Subject: [PATCH] Remove interaction with `COMAR` component

This removes eopkg support for interacting directly with COMAR, and
instead will only allow COMAR to talk to pisi/eopkg. Instead, all
configuration requests will be proxied to `usysconf` at the end of
each transaction.

We achieve this by wrapping the currently unsafe transactions in
a try/finally block and make sure usysconf will ALWAYS run for any
actionable transaction. After that, it's entirely up to usysconf to
do something with the system.

Note that due to the way pisi has traditionally used COMAR, we cannot
realistically delete the comariface file. This is imported dynamically
at runtime by the existing eopkg on disk, and failure to import it
with the old process would break the update, resulting in comar-api
issues.

As such we safe-guard that transition element of the process, and ensure
the newly run eopkg will never talk to COMAR for postinstall tasks again.
This will require some jostling from kernel-glue package to unconditionally
run `usysconf` during the very last use of COMAR to ensure system
consistency until the new eopkg takes over.

Signed-off-by: Ikey Doherty <ikey@solus-project.com>
---
 pisi/api.py                | 95 +++++++++++-----------------------------------
 pisi/archive.py            | 12 ------
 pisi/atomicoperations.py   | 72 +----------------------------------
 pisi/cli/build.py          |  1 -
 pisi/cli/command.py        |  9 +++--
 pisi/cli/emerge.py         |  2 +-
 pisi/context.py            | 33 ++++++++++++++--
 pisi/operations/install.py | 24 +++++++++---
 pisi/operations/remove.py  | 15 +++++---
 pisi/operations/upgrade.py | 20 +++++-----
 10 files changed, 96 insertions(+), 187 deletions(-)

diff --git a/pisi/api.py b/pisi/api.py
index 011f5e4..71b669e 100644
--- a/pisi/api.py
+++ b/pisi/api.py
@@ -93,48 +93,9 @@ def set_io_streams(stdout=None, stderr=None):
     if stderr:
         ctx.stderr = stderr
 
-def set_comar(enable):
-    """
-    Set comar usage
-    False means no preremove and postinstall scripts will be run
-    @param enable: Flag indicating comar usage
-    """
-    ctx.comar = enable
-
-def set_comar_updated(updated):
-    """
-    Set comar package update status
-    @param updated: True if COMAR package is updated, else False
-    """
-    ctx.comar_updated = updated
-
-def set_dbus_sockname(sockname):
-    """
-    Set dbus socket file
-    Used by YALI
-    @param sockname: Path to dbus socket file
-    """
-    ctx.dbus_sockname = sockname
-
-def set_dbus_timeout(timeout):
-    """
-    Set dbus timeout
-    Used by YALI
-    @param timeout: Timeout in seconds
-    """
-    ctx.dbus_timeout = timeout
-
-def set_signal_handling(enable):
-    """
-    Enable signal handling. Signal handling in pisi mostly used for disabling keyboard interrupts
-    in critical paths.
-    Used by YALI
-    @param enable: Flag indicating signal handling usage
-    """
-    if enable:
-        ctx.sig = pisi.signalhandler.SignalHandler()
-    else:
-        ctx.sig = None
+def set_can_configure(configure):
+    """ Specify whether we're allowed to run usysconf """
+    ctx.can_usysconf = configure
 
 def set_options(options):
     """
@@ -692,9 +653,6 @@ def generate_pending_order(A):
 
 @locked
 def configure_pending(packages=None):
-    # Import COMAR
-    import pisi.comariface
-
     # start with pending packages
     # configure them in reverse topological order of dependency
     installdb = pisi.db.installdb.InstallDB()
@@ -703,33 +661,26 @@ def configure_pending(packages=None):
     else:
         packages = set(packages).intersection(installdb.list_pending())
 
-    order = generate_pending_order(packages)
     try:
-        for x in order:
-            if installdb.has_package(x):
-                pkginfo = installdb.get_package(x)
-                pkg_path = installdb.package_path(x)
-                m = pisi.metadata.MetaData()
-                metadata_path = pisi.util.join_path(pkg_path, ctx.const.metadata_xml)
-                m.read(metadata_path)
-                # FIXME: we need a full package info here!
-                pkginfo.name = x
-                ctx.ui.notify(pisi.ui.configuring, package = pkginfo, files = None)
-                pisi.comariface.post_install(
-                    pkginfo.name,
-                    m.package.providesComar,
-                    pisi.util.join_path(pkg_path, ctx.const.comar_dir),
-                    pisi.util.join_path(pkg_path, ctx.const.metadata_xml),
-                    pisi.util.join_path(pkg_path, ctx.const.files_xml),
-                    None,
-                    None,
-                    m.package.version,
-                    m.package.release
-                )
-                ctx.ui.notify(pisi.ui.configured, package = pkginfo, files = None)
-            installdb.clear_pending(x)
-    except ImportError:
-        raise pisi.Error(_("comar package is not fully installed"))
+        ctx.exec_usysconf()
+    except Exception as e:
+        raise e
+        return
+
+    # Clear legacy "needs configuration" flag
+    order = generate_pending_order(packages)
+    for x in order:
+        if installdb.has_package(x):
+            pkginfo = installdb.get_package(x)
+            pkg_path = installdb.package_path(x)
+            m = pisi.metadata.MetaData()
+            metadata_path = pisi.util.join_path(pkg_path, ctx.const.metadata_xml)
+            m.read(metadata_path)
+            # FIXME: we need a full package info here!
+            pkginfo.name = x
+            ctx.ui.notify(pisi.ui.configuring, package = pkginfo, files = None)
+            ctx.ui.notify(pisi.ui.configured, package = pkginfo, files = None)
+        installdb.clear_pending(x)
 
 def info(package, installed = False):
     if package.endswith(ctx.const.package_suffix):
@@ -883,7 +834,6 @@ def rebuild_db(files=False):
     # save parameters and shutdown pisi
     options = ctx.config.options
     ui = ctx.ui
-    comar = ctx.comar
     pisi._cleanup()
 
     filesdb.close()
@@ -893,7 +843,6 @@ def rebuild_db(files=False):
     # reinitialize everything
     set_userinterface(ui)
     set_options(options)
-    set_comar(comar)
 
     # construct new database
     rebuild_filesdb()
diff --git a/pisi/archive.py b/pisi/archive.py
index 70bd68c..196ead1 100644
--- a/pisi/archive.py
+++ b/pisi/archive.py
@@ -301,7 +301,6 @@ class ArchiveTar(ArchiveBase):
             if callback:
                 callback(tarinfo, extracted=False)
 
-            startservices = []
             if tarinfo.issym() and \
                     os.path.isdir(tarinfo.name) and \
                     not os.path.islink(tarinfo.name):
@@ -344,16 +343,6 @@ class ArchiveTar(ArchiveBase):
                     except OSError, e:
                         # hmmm, not empty dir? try rename it adding .old extension.
                         if e.errno == errno.ENOTEMPTY:
-                            # if directory with dbus/pid file was moved we have to restart dbus
-                            for (path, dirs, files) in os.walk(tarinfo.name):
-                                if path.endswith("dbus") and "pid" in files:
-                                    startservices.append("dbus")
-                                    for service in ("NetworkManager", "connman", "wicd"):
-                                        if os.path.isfile("/etc/mudur/services/enabled/%s" % service):
-                                            startservices.append(service)
-                                            os.system("service % stop" % service)
-                                    os.system("service dbus stop")
-                                    break
                             os.system("mv -f %s %s.old" % (tarinfo.name, tarinfo.name))
                         else:
                             raise
@@ -375,7 +364,6 @@ class ArchiveTar(ArchiveBase):
 
             try:
                 self.tar.extract(tarinfo)
-                for service in startservices: os.system("service %s start" % service)
             except OSError, e:
                 # Handle the case where an upper directory cannot
                 # be created because of a conflict with an existing
diff --git a/pisi/atomicoperations.py b/pisi/atomicoperations.py
index 8091c76..588510f 100644
--- a/pisi/atomicoperations.py
+++ b/pisi/atomicoperations.py
@@ -148,7 +148,6 @@ class Install(AtomicOperation):
         ctx.ui.notify(pisi.ui.installing, package=self.pkginfo, files=self.files)
 
         self.ask_reinstall = ask_reinstall
-        self.check_requirements()
         self.check_versioning(self.pkginfo.version, self.pkginfo.release)
         self.check_relations()
         self.check_operation()
@@ -157,7 +156,6 @@ class Install(AtomicOperation):
 
         self.extract_install()
         self.store_pisi_files()
-        self.postinstall()
         self.update_databases()
 
         ctx.enable_keyboard_interrupts()
@@ -169,15 +167,6 @@ class Install(AtomicOperation):
             event = pisi.ui.installed
         ctx.ui.notify(event, package = self.pkginfo, files = self.files)
 
-    def check_requirements(self):
-        """check system requirements"""
-        #TODO: IS THERE ENOUGH SPACE?
-        # what to do if / is split into /usr, /var, etc.
-        # check comar
-        if self.metadata.package.providesComar and ctx.comar:
-            import pisi.comariface as comariface
-            comariface.get_link()
-
     def check_replaces(self):
         for replaced in self.pkginfo.replaces:
             if self.installdb.has_package(replaced.package):
@@ -274,42 +263,10 @@ class Install(AtomicOperation):
             self.old_pkginfo = self.installdb.get_info(pkg.name)
             self.old_path = self.installdb.pkg_dir(pkg.name, iversion_s, irelease_s)
             self.remove_old = Remove(pkg.name)
-            self.remove_old.run_preremove()
-            self.remove_old.run_postremove()
 
     def reinstall(self):
         return not self.operation == INSTALL
 
-    def postinstall(self):
-        self.config_later = False
-        if ctx.comar:
-            import pisi.comariface
-            try:
-                if self.operation == UPGRADE or self.operation == DOWNGRADE:
-                    fromVersion = self.old_pkginfo.version
-                    fromRelease = self.old_pkginfo.release
-                else:
-                    fromVersion = None
-                    fromRelease = None
-                ctx.ui.notify(pisi.ui.configuring, package = self.pkginfo, files = self.files)
-                pisi.comariface.post_install(
-                    self.pkginfo.name,
-                    self.metadata.package.providesComar,
-                    self.package.comar_dir(),
-                    os.path.join(self.package.pkg_dir(), ctx.const.metadata_xml),
-                    os.path.join(self.package.pkg_dir(), ctx.const.files_xml),
-                    fromVersion,
-                    fromRelease,
-                    self.metadata.package.version,
-                    self.metadata.package.release
-                    )
-                ctx.ui.notify(pisi.ui.configured, package = self.pkginfo, files = self.files)
-            except pisi.comariface.Error:
-                ctx.ui.warning(_('%s configuration failed.') % self.pkginfo.name)
-                self.config_later = True
-        else:
-            self.config_later = True
-
     def extract_install(self):
         "unzip package in place"
 
@@ -505,19 +462,13 @@ class Install(AtomicOperation):
         if self.reinstall():
             self.remove_old.remove_db()
 
-        if self.config_later:
-            self.installdb.mark_pending(self.pkginfo.name)
-
-        # need service or system restart?
+        # need system restart?
         if self.installdb.has_package(self.pkginfo.name):
             (version, release, build) = self.installdb.get_version(self.pkginfo.name)
             actions = self.pkginfo.get_update_actions(release)
         else:
             actions = self.pkginfo.get_update_actions("1")
 
-        for package_name in actions.get("serviceRestart", []):
-            pisi.api.add_needs_restart(package_name)
-
         for package_name in actions.get("systemRestart", []):
             pisi.api.add_needs_reboot(package_name)
 
@@ -578,12 +529,9 @@ class Remove(AtomicOperation):
 
         self.check_dependencies()
 
-        self.run_preremove()
         for fileinfo in self.files.list:
             self.remove_file(fileinfo, self.package_name, True)
 
-        self.run_postremove()
-
         self.update_databases()
 
         self.remove_pisi_files()
@@ -651,24 +599,6 @@ class Remove(AtomicOperation):
             os.rmdir(dpath)
             dpath = os.path.dirname(dpath)
 
-    def run_preremove(self):
-        if ctx.comar:
-            import pisi.comariface
-            pisi.comariface.pre_remove(
-                self.package_name,
-                os.path.join(self.package.pkg_dir(), ctx.const.metadata_xml),
-                os.path.join(self.package.pkg_dir(), ctx.const.files_xml),
-            )
-
-    def run_postremove(self):
-        if ctx.comar:
-            import pisi.comariface
-            pisi.comariface.post_remove(
-                self.package_name,
-                os.path.join(self.package.pkg_dir(), ctx.const.metadata_xml),
-                os.path.join(self.package.pkg_dir(), ctx.const.files_xml),
-                provided_scripts=self.package.providesComar,
-            )
 
     def update_databases(self):
         self.remove_db()
diff --git a/pisi/cli/build.py b/pisi/cli/build.py
index 91349b1..672782b 100644
--- a/pisi/cli/build.py
+++ b/pisi/cli/build.py
@@ -41,7 +41,6 @@ class Build(command.Command):
 
     def __init__(self, args):
         super(Build, self).__init__(args)
-        self.comar = True
 
     name = ("build", "bi")
 
diff --git a/pisi/cli/command.py b/pisi/cli/command.py
index a3f76c2..f2aa94e 100644
--- a/pisi/cli/command.py
+++ b/pisi/cli/command.py
@@ -77,7 +77,6 @@ class Command(object):
     def __init__(self, args = None):
         # now for the real parser
         import pisi
-        self.comar = False
         self.parser = optparse.OptionParser(usage=getattr(self, "__doc__"),
                                             version="%prog " + pisi.__version__,
                                             formatter=PisiHelpFormatter())
@@ -167,7 +166,12 @@ class Command(object):
 
         pisi.api.set_userinterface(ui)
         pisi.api.set_options(self.options)
-        pisi.api.set_comar(self.comar and not ctx.get_option('ignore_comar'))
+
+        # Disable configuration for destdir ops (ISO builds and such)
+        if self.options.destdir and self.options.destdir != '/':
+            pisi.api.set_can_configure(False)
+        else:
+            pisi.api.set_can_configure(not ctx.get_option('ignore_comar'))
 
     def get_name(self):
         return self.__class__.name
@@ -196,7 +200,6 @@ class PackageOp(Command):
 
     def __init__(self, args):
         super(PackageOp, self).__init__(args)
-        self.comar = True
 
     def options(self, group):
         group.add_option("--ignore-dependency", action="store_true",
diff --git a/pisi/cli/emerge.py b/pisi/cli/emerge.py
index dd807c5..0e676e2 100644
--- a/pisi/cli/emerge.py
+++ b/pisi/cli/emerge.py
@@ -35,7 +35,6 @@ You can also give the name of a component.
 
     def __init__(self, args):
         super(Emerge, self).__init__(args)
-        self.comar = True
 
     name = ("emerge", "em")
 
@@ -73,5 +72,6 @@ You can also give the name of a component.
             ctx.ui.info(_('Outputting binary packages in the package cache.'))
             ctx.config.options.output_dir = ctx.config.cached_packages_dir()
 
+        pisi.api.set_can_configure(not ctx.get_option('ignore_comar'))
         pisi.api.emerge(sources)
 
diff --git a/pisi/context.py b/pisi/context.py
index 227150a..91c3348 100644
--- a/pisi/context.py
+++ b/pisi/context.py
@@ -13,11 +13,16 @@
 # global variables here
 
 import signal
+import os
 
 import pisi.constants
 import pisi.signalhandler
 import pisi.ui
 
+import gettext
+__trans = gettext.translation('pisi', fallback=True)
+_ = __trans.ugettext
+
 const = pisi.constants.Constants()
 sig = pisi.signalhandler.SignalHandler()
 
@@ -40,10 +45,9 @@ ui = pisi.ui.UI()
 stdout = None
 stderr = None
 
-comar = True
-comar_updated = False
-dbus_sockname = None
-dbus_timeout = 60 * 60 # in seconds
+# usysconf binary
+usysconf_binary = "/usr/sbin/usysconf"
+can_usysconf = True
 
 # Bug #2879
 # FIXME: Maybe we can create a simple rollback mechanism. There are other
@@ -62,3 +66,24 @@ def keyboard_interrupt_disabled():
 
 def keyboard_interrupt_pending():
     return sig and sig.signal_pending(signal.SIGINT)
+
+def exec_usysconf():
+    """ Just stick this all in the one place """
+    global ui
+    global usysconf_binary
+    global can_usysconf
+
+    if not can_usysconf:
+        return
+
+    # We must survive not having usysconf just in case of derp.
+    if not os.path.exists(usysconf_binary):
+        ui.error(_('usysconf not installed. Please upgrade!'))
+        return
+
+    try:
+        os.system("{} run".format(usysconf_binary))
+    except Exception as e:
+        if ctx:
+            ctx.ui.error(_('Failed to configure system'))
+        raise e
diff --git a/pisi/operations/install.py b/pisi/operations/install.py
index 1cdc650..6430e9d 100644
--- a/pisi/operations/install.py
+++ b/pisi/operations/install.py
@@ -103,10 +103,16 @@ def install_pkg_names(A, reinstall = False):
     if conflicts:
         operations.remove.remove_conflicting_packages(conflicts)
 
-    for path in paths:
-        ctx.ui.info(util.colorize(_("Installing %d / %d") % (paths.index(path)+1, len(paths)), "yellow"))
-        install_op = atomicoperations.Install(path)
-        install_op.install(False)
+    try:
+        for path in paths:
+            ctx.ui.info(util.colorize(_("Installing %d / %d") % (paths.index(path)+1, len(paths)), "yellow"))
+            install_op = atomicoperations.Install(path)
+            install_op.install(False)
+    except Exception as e:
+        raise e
+        return False
+    finally:
+        ctx.exec_usysconf()
 
     return True
 
@@ -248,8 +254,14 @@ def install_pkg_files(package_URIs, reinstall = False):
 
     ctx.ui.notify(ui.packagestogo, order = order)
 
-    for x in order:
-        atomicoperations.install_single_file(dfn[x], reinstall)
+    try:
+        for x in order:
+            atomicoperations.install_single_file(dfn[x], reinstall)
+    except Exception as e:
+        raise e
+        return False
+    finally:
+        ctx.exec_usysconf()
 
     return True
 
diff --git a/pisi/operations/remove.py b/pisi/operations/remove.py
index 0307cd8..976bf02 100644
--- a/pisi/operations/remove.py
+++ b/pisi/operations/remove.py
@@ -78,11 +78,16 @@ in the respective order to satisfy dependencies:
 
     ctx.ui.notify(ui.packagestogo, order = order)
 
-    for x in order:
-        if installdb.has_package(x):
-            atomicoperations.remove_single(x)
-        else:
-            ctx.ui.info(_('Package %s is not installed. Cannot remove.') % x)
+    try:
+        for x in order:
+            if installdb.has_package(x):
+                atomicoperations.remove_single(x)
+            else:
+                ctx.ui.info(_('Package %s is not installed. Cannot remove.') % x)
+    except Exception as e:
+        raise e
+    finally:
+        ctx.exec_usysconf()
 
 def plan_remove(A):
     # try to construct a pisi graph of packages to
diff --git a/pisi/operations/upgrade.py b/pisi/operations/upgrade.py
index 628c43f..16ee686 100644
--- a/pisi/operations/upgrade.py
+++ b/pisi/operations/upgrade.py
@@ -47,13 +47,6 @@ def check_update_actions(packages):
 
     has_actions = False
 
-    if "serviceRestart" in actions:
-        has_actions = True
-        ctx.ui.warning(_("You must restart the following service(s) manually "
-                         "for the updated software to take effect:"))
-        for package, target in actions["serviceRestart"]:
-            ctx.ui.info("    - %s" % target)
-
     if "systemRestart" in actions:
         has_actions = True
         ctx.ui.warning(_("You must restart your system for the updates "
@@ -202,10 +195,15 @@ def upgrade(A=[], repo=None):
 
     operations.remove.remove_obsoleted_packages()
 
-    for path in paths:
-        ctx.ui.info(util.colorize(_("Installing %d / %d") % (paths.index(path)+1, len(paths)), "yellow"))
-        install_op = atomicoperations.Install(path, ignore_file_conflicts = True)
-        install_op.install(True)
+    try:
+        for path in paths:
+            ctx.ui.info(util.colorize(_("Installing %d / %d") % (paths.index(path)+1, len(paths)), "yellow"))
+            install_op = atomicoperations.Install(path, ignore_file_conflicts = True)
+            install_op.install(True)
+    except Exception as e:
+        raise e
+    finally:
+        ctx.exec_usysconf()
 
 def plan_upgrade(A, force_replaced=True, replaces=None):
     # FIXME: remove force_replaced
-- 
2.15.0

