From 2f74fc3f434303918fc94af053dbe2d931153925 Mon Sep 17 00:00:00 2001
From: Ikey Doherty <ikey@solus-project.com>
Date: Thu, 7 Dec 2017 15:08:58 +0000
Subject: [PATCH 1/6] installdb: Flag any package that is automatically
 installed

This will let us add flags for each package that was somehow automatically
installed on the system, i.e. as an automatic dependency of another Thing
that wasn't within the set of packages requested for installation.

This will be useful in future when we add a command to analyze the system
for orphan packages, i.e. a plan remove for all the orphan names that can
be removed safely because they don't have reverse dependencies outside of
the flagged set.

Signed-off-by: Ikey Doherty <ikey@solus-project.com>
---
 pisi/api.py                | 18 ++++++++++++++++++
 pisi/atomicoperations.py   | 11 +++++++++++
 pisi/constants.py          |  1 +
 pisi/db/installdb.py       |  9 +++++++++
 pisi/operations/helper.py  | 24 ++++++++++++++++++++++++
 pisi/operations/install.py |  3 +++
 pisi/operations/upgrade.py |  4 ++++
 7 files changed, 70 insertions(+)

diff --git a/pisi/api.py b/pisi/api.py
index 71b669e..a2869fb 100644
--- a/pisi/api.py
+++ b/pisi/api.py
@@ -125,6 +125,12 @@ def list_needs_reboot():
     """
     return pisi.db.installdb.InstallDB().list_needs_reboot()
 
+def list_auto_installed():
+    """
+    Return a list of packages that have been automatically installed.
+    """
+    return pisi.db.installdb.InstallDB().list_auto_installed()
+
 def add_needs_restart(package):
     """
     Add a new package to service restart list.
@@ -137,6 +143,12 @@ def add_needs_reboot(package):
     """
     pisi.db.installdb.InstallDB().mark_needs_reboot(package)
 
+def add_auto_installed(package):
+    """
+    Add a new package to the auto installed list.
+    """
+    pisi.db.installdb.InstallDB().mark_auto_installed(package)
+
 def remove_needs_restart(package):
     """
     Remove a package from service restart list. Passing "*" will clear whole list.
@@ -149,6 +161,12 @@ def remove_needs_reboot(package):
     """
     pisi.db.installdb.InstallDB().clear_needs_reboot(package)
 
+def remove_auto_install(package):
+    """
+    Remove a package from the auto install list. Passing "*" will clear whole list.
+    """
+    pisi.db.installdb.InstallDB().clear_auto_installed(package)
+
 def list_pending():
     """
     Return a list of configuration pending packages -> list_of_strings
diff --git a/pisi/atomicoperations.py b/pisi/atomicoperations.py
index 588510f..2e4b226 100644
--- a/pisi/atomicoperations.py
+++ b/pisi/atomicoperations.py
@@ -60,6 +60,9 @@ opttostr = {INSTALL:"install", REMOVE:"remove", REINSTALL:"reinstall", UPGRADE:"
 class Install(AtomicOperation):
     "Install class, provides install routines for pisi packages"
 
+    # Is this an automatic install?
+    automatic = False
+
     @staticmethod
     def from_name(name, ignore_dep = None):
         packagedb = pisi.db.packagedb.PackageDB()
@@ -136,6 +139,7 @@ class Install(AtomicOperation):
         self.filesdb = pisi.db.filesdb.FilesDB()
         self.installdb = pisi.db.installdb.InstallDB()
         self.operation = INSTALL
+        self.automatic = False
 
     def install(self, ask_reinstall = True):
 
@@ -478,6 +482,12 @@ class Install(AtomicOperation):
         # installed packages
         self.installdb.add_package(self.pkginfo)
 
+        # If we're manually installed, remove flag
+        if self.automatic:
+            self.installdb.mark_auto_installed(self.pkginfo.name)
+        else:
+            self.installdb.clear_auto_installed(self.pkginfo.name)
+
         otype = "delta" if self.package_fname.endswith(ctx.const.delta_package_suffix) else None
         self.historydb.add_and_update(pkgBefore=self.old_pkginfo, pkgAfter=self.pkginfo, operation=opttostr[self.operation], otype=otype)
 
@@ -609,6 +619,7 @@ class Remove(AtomicOperation):
 
     def remove_db(self):
         self.installdb.remove_package(self.package_name)
+        self.installdb.clear_auto_installed(self.package_name)
         self.filesdb.remove_files(self.files.list)
 # FIX:DB
 #         # FIXME: something goes wrong here, if we use ctx operations ends up with segmentation fault!
diff --git a/pisi/constants.py b/pisi/constants.py
index 1afdb91..87dfc00 100644
--- a/pisi/constants.py
+++ b/pisi/constants.py
@@ -97,6 +97,7 @@ class Constants:
         self.__c.config_pending = "configpending"
         self.__c.needs_restart = "needsrestart"
         self.__c.needs_reboot = "needsreboot"
+        self.__c.auto_installed = "autoinstalled"
         self.__c.files_db = "files.db"
         self.__c.repos = "repos"
         self.__c.devel_package_end = "-devel"
diff --git a/pisi/db/installdb.py b/pisi/db/installdb.py
index 15b6119..34ef003 100644
--- a/pisi/db/installdb.py
+++ b/pisi/db/installdb.py
@@ -289,6 +289,9 @@ class InstallDB(lazydb.LazyDB):
     def mark_needs_reboot(self, package):
         self.__mark_package(ctx.const.needs_reboot, package)
 
+    def mark_auto_installed(self, package):
+        self.__mark_package(ctx.const.auto_installed, package)
+
     def add_package(self, pkginfo):
         # Cleanup old revdep info
         for revdep_info in self.rev_deps_db.values():
@@ -318,6 +321,9 @@ class InstallDB(lazydb.LazyDB):
     def list_needs_reboot(self):
         return self.__get_marked_packages(ctx.const.needs_reboot)
 
+    def list_auto_installed(self):
+        return self.__get_marked_packages(ctx.const.auto_installed)
+
     def __write_marked_packages(self, _type, packages):
         info_file = os.path.join(ctx.config.info_dir(), _type)
         config = open(info_file, "w")
@@ -343,6 +349,9 @@ class InstallDB(lazydb.LazyDB):
     def clear_needs_reboot(self, package):
         self.__clear_marked_packages(ctx.const.needs_reboot, package)
 
+    def clear_auto_installed(self, package):
+        self.__clear_marked_packages(ctx.const.auto_installed, package)
+
     def package_path(self, package):
 
         if self.installed_db.has_key(package):
diff --git a/pisi/operations/helper.py b/pisi/operations/helper.py
index 8a53fd2..b83831d 100644
--- a/pisi/operations/helper.py
+++ b/pisi/operations/helper.py
@@ -74,6 +74,30 @@ def expand_src_components(A):
             Ap.add(x)
     return Ap
 
+def extract_automatic(A, total):
+    """
+    Determine all automatic dependencies in the graph.
+
+    This is only applicable to packages coming from the repo
+    """
+
+    ret = set()
+    installdb = pisi.db.installdb.InstallDB()
+    packagedb = pisi.db.packagedb.PackageDB()
+
+    for i in total:
+        if i in A:
+            continue
+        repoVariant = packagedb.get_package(i)
+        # system.base candidate is never "automatic" ...
+        if repoVariant.partOf == "system.base":
+            continue
+        if installdb.has_package(i):
+            continue
+        ret.add(i)
+
+    return ret
+
 def calculate_download_sizes(order):
     total_size = cached_size = 0
 
diff --git a/pisi/operations/install.py b/pisi/operations/install.py
index 6430e9d..56f3406 100644
--- a/pisi/operations/install.py
+++ b/pisi/operations/install.py
@@ -90,6 +90,7 @@ def install_pkg_names(A, reinstall = False):
     if not ctx.get_option('ignore_package_conflicts'):
         conflicts = operations.helper.check_conflicts(order, packagedb)
 
+    automatic = operations.helper.extract_automatic(A, order)
     paths = []
     for x in order:
         ctx.ui.info(util.colorize(_("Downloading %d / %d") % (order.index(x)+1, len(order)), "yellow"))
@@ -107,6 +108,8 @@ def install_pkg_names(A, reinstall = False):
         for path in paths:
             ctx.ui.info(util.colorize(_("Installing %d / %d") % (paths.index(path)+1, len(paths)), "yellow"))
             install_op = atomicoperations.Install(path)
+            if install_op.pkginfo.name in automatic:
+                install_op.automatic = True
             install_op.install(False)
     except Exception as e:
         raise e
diff --git a/pisi/operations/upgrade.py b/pisi/operations/upgrade.py
index 16ee686..1c2c953 100644
--- a/pisi/operations/upgrade.py
+++ b/pisi/operations/upgrade.py
@@ -180,6 +180,8 @@ def upgrade(A=[], repo=None):
     if not ctx.get_option('ignore_package_conflicts'):
         conflicts = operations.helper.check_conflicts(order, packagedb)
 
+
+    automatic = operations.helper.extract_automatic(A, order)
     paths = []
     for x in order:
         ctx.ui.info(util.colorize(_("Downloading %d / %d") % (order.index(x)+1, len(order)), "yellow"))
@@ -199,6 +201,8 @@ def upgrade(A=[], repo=None):
         for path in paths:
             ctx.ui.info(util.colorize(_("Installing %d / %d") % (paths.index(path)+1, len(paths)), "yellow"))
             install_op = atomicoperations.Install(path, ignore_file_conflicts = True)
+            if install_op.pkginfo.name in automatic:
+                install_op.automatic = True
             install_op.install(True)
     except Exception as e:
         raise e
-- 
2.15.1

